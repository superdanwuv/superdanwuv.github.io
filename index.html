<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>자막 프리뷰어 - 반응형 모드</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap');

        body {
            font-family: 'Noto Sans KR', sans-serif;
            background-color: #1a1a1a;
            color: #e5e5e5;
            margin: 0;
            overflow: hidden;
        }

        /* 반응형 레이아웃 컨테이너 */
        .editor-container {
            height: 100vh;
            display: flex;
            flex-direction: column; /* 기본: 모바일용 세로 배치 */
        }

        /* PC 버전 (화면이 넓을 때) */
        @media (min-width: 768px) {
            .editor-container {
                flex-direction: row; /* 가로 분할 */
            }
            .input-section {
                width: 400px;
                height: 100%;
                border-right: 1px solid #404040;
                border-bottom: none;
            }
        }

        .input-section {
            background-color: #262626;
            display: flex;
            flex-direction: column;
            padding: 1rem;
            z-index: 10;
            height: 40%; /* 모바일에서 입력창 높이 */
            border-bottom: 1px solid #404040;
        }

        .preview-section {
            flex-grow: 1;
            background-color: #000;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        textarea {
            flex-grow: 1;
            background-color: #121212;
            color: #00ff41;
            font-family: 'Courier New', Courier, monospace;
            padding: 0.75rem;
            border-radius: 0.5rem;
            border: 1px solid #404040;
            resize: none;
            outline: none;
            font-size: 0.85rem;
        }

        /* Subtitle Styling */
        #subtitle-display {
            color: white;
            font-size: 1.8rem; /* 모바일 기본 크기 */
            text-align: center;
            text-shadow: 2px 2px 10px rgba(0, 0, 0, 1);
            max-width: 90%;
            line-height: 1.4;
            transition: opacity 0.2s ease;
            pointer-events: none;
            white-space: pre-wrap;
            font-weight: 700;
        }

        @media (min-width: 768px) {
            #subtitle-display {
                font-size: 3rem; /* PC에서 더 크게 */
            }
        }

        /* 전체화면일 때 자막 크기 조정 */
        :fullscreen #subtitle-display {
            font-size: 6vw;
        }

        .controls {
            position: absolute;
            bottom: 1.5rem;
            background: rgba(40, 40, 40, 0.85);
            padding: 0.6rem 1rem;
            border-radius: 9999px;
            display: flex;
            gap: 1rem;
            align-items: center;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            transition: opacity 0.3s;
            width: 90%;
            max-width: 500px;
            justify-content: space-between;
        }

        /* 전체화면에서 마우스 움직임이 없으면 컨트롤 숨기기 */
        .preview-section.hide-cursor .controls {
            opacity: 0;
        }

        .time-display {
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.9rem;
            color: #fbbf24;
            min-width: 65px;
            text-align: right;
        }

        button:active {
            transform: scale(0.92);
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 5px;
        }

        /* 슬라이더 모바일 터치 최적화 */
        input[type="range"] {
            flex: 1;
            cursor: pointer;
        }
    </style>
</head>
<body>

<div class="editor-container">
    <!-- 입력 섹션 (모바일에서는 상단) -->
    <div class="input-section">
        <div class="flex justify-between items-center mb-2">
            <h1 class="text-lg font-bold text-indigo-400">Subtitle Editor</h1>
            <div id="parse-status" class="text-[10px] text-gray-400 bg-black/20 px-2 py-1 rounded-full">
                <span class="status-dot bg-green-500"></span> 로드됨
            </div>
        </div>
        
        <textarea id="vtt-input" spellcheck="false" placeholder="자막을 입력하세요...">1
00:00:00,500 --> 00:00:03,000
<b>반응형 모드</b>가 적용되었습니다!

2
00:00:04,000 --> 00:00:08,000
모바일에서는 입력창이 위에,
자막 화면이 아래에 나옵니다.</textarea>

        <div class="mt-2 flex gap-2">
            <button id="apply-btn" class="flex-1 bg-indigo-600 hover:bg-indigo-500 text-white py-2 rounded-lg font-bold text-sm shadow-lg">
                적용하기
            </button>
        </div>
    </div>

    <!-- 미리보기 섹션 (모바일에서는 하단) -->
    <div class="preview-section" id="fullscreen-target">
        <div id="subtitle-display"></div>

        <div class="controls">
            <!-- 재생/일시정지 -->
            <button id="play-pause" class="text-white">
                <svg id="play-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16">
                    <path d="m11.596 8.697-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z"/>
                </svg>
                <svg id="pause-icon" class="hidden" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16">
                    <path d="M5.5 3.5A1.5 1.5 0 0 1 7 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5zm5 0A1.5 1.5 0 0 1 12 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5z"/>
                </svg>
            </button>
            
            <!-- 탐색 바 -->
            <input type="range" id="seek-bar" class="accent-indigo-500" value="0" step="0.05">
            
            <!-- 시간 -->
            <div class="time-display" id="time-display">00:00.0</div>
            
            <!-- 전체화면 버튼 -->
            <button id="fullscreen-btn" class="text-white ml-1">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16">
                    <path d="M1.5 1a.5.5 0 0 0-.5.5v4a.5.5 0 0 1-1 0v-4A1.5 1.5 0 0 1 1.5 0h4a.5.5 0 0 1 0 1h-4zM10 .5a.5.5 0 0 1 .5-.5h4A1.5 1.5 0 0 1 16 1.5v4a.5.5 0 0 1-1 0v-4a.5.5 0 0 0-.5-.5h-4a.5.5 0 0 1-.5-.5zM.5 10a.5.5 0 0 1 .5.5v4a.5.5 0 0 0 .5.5h4a.5.5 0 0 1 0 1h-4A1.5 1.5 0 0 1 0 14.5v-4a.5.5 0 0 1 .5-.5zm15 0a.5.5 0 0 1 .5.5v4a1.5 1.5 0 0 1-1.5 1.5h-4a.5.5 0 0 1 0-1h4a.5.5 0 0 0 .5-.5v-4a.5.5 0 0 1 .5-.5z"/>
                </svg>
            </button>
        </div>
    </div>
</div>

<script>
    const vttInput = document.getElementById('vtt-input');
    const subtitleDisplay = document.getElementById('subtitle-display');
    const playPauseBtn = document.getElementById('play-pause');
    const seekBar = document.getElementById('seek-bar');
    const timeDisplay = document.getElementById('time-display');
    const applyBtn = document.getElementById('apply-btn');
    const fullscreenBtn = document.getElementById('fullscreen-btn');
    const fullscreenTarget = document.getElementById('fullscreen-target');
    const playIcon = document.getElementById('play-icon');
    const pauseIcon = document.getElementById('pause-icon');
    const statusDot = document.querySelector('.status-dot');
    const statusText = document.getElementById('parse-status');

    let cues = [];
    let currentTime = 0;
    let isPlaying = false;
    let lastTimestamp = 0;
    let maxTime = 10;
    let hideTimer;

    function parseSubtitles(text) {
        const lines = text.replace(/\r\n/g, '\n').split('\n');
        const parsedCues = [];
        let currentCue = null;
        const timeRegex = /(\d{2}:\d{2}:\d{2}[.,]\d{3}) --> (\d{2}:\d{2}:\d{2}[.,]\d{3})/;

        lines.forEach(line => {
            const trimmedLine = line.trim();
            const timeMatch = trimmedLine.match(timeRegex);

            if (timeMatch) {
                if (currentCue) parsedCues.push(currentCue);
                currentCue = {
                    start: timeToSeconds(timeMatch[1]),
                    end: timeToSeconds(timeMatch[2]),
                    text: ""
                };
            } else if (currentCue && trimmedLine !== "") {
                if (trimmedLine.toUpperCase() !== 'WEBVTT' && !/^\d+$/.test(trimmedLine)) {
                    currentCue.text += (currentCue.text ? "\n" : "") + trimmedLine;
                }
            } else if (trimmedLine === "" && currentCue) {
                parsedCues.push(currentCue);
                currentCue = null;
            }
        });
        if (currentCue) parsedCues.push(currentCue);
        return parsedCues.filter(c => c.text !== "").sort((a, b) => a.start - b.start);
    }

    function timeToSeconds(timeStr) {
        const normalized = timeStr.replace(',', '.');
        const parts = normalized.split(':');
        return (parseInt(parts[0]) * 3600) + (parseInt(parts[1]) * 60) + parseFloat(parts[2]);
    }

    function formatTime(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = (seconds % 60).toFixed(1);
        return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(4, '0')}`;
    }

    function updateDisplay() {
        const activeCue = cues.find(cue => currentTime >= cue.start && currentTime <= cue.end);
        if (activeCue) {
            if (subtitleDisplay.innerHTML !== activeCue.text) {
                subtitleDisplay.innerHTML = activeCue.text;
                subtitleDisplay.style.opacity = 1;
            }
        } else {
            subtitleDisplay.style.opacity = 0;
        }
        timeDisplay.innerText = formatTime(currentTime);
        seekBar.value = currentTime;
    }

    function step(timestamp) {
        if (!isPlaying) return;
        if (!lastTimestamp) lastTimestamp = timestamp;
        const progress = (timestamp - lastTimestamp) / 1000;
        lastTimestamp = timestamp;

        currentTime += progress;
        if (currentTime > maxTime) {
            currentTime = 0;
            isPlaying = false;
            updatePlayIcon();
        }
        updateDisplay();
        requestAnimationFrame(step);
    }

    function updatePlayIcon() {
        if (isPlaying) {
            playIcon.classList.add('hidden');
            pauseIcon.classList.remove('hidden');
        } else {
            playIcon.classList.remove('hidden');
            pauseIcon.classList.add('hidden');
        }
    }

    function togglePlay() {
        if (cues.length === 0) return;
        isPlaying = !isPlaying;
        updatePlayIcon();
        if (isPlaying) {
            lastTimestamp = 0;
            requestAnimationFrame(step);
        }
    }

    fullscreenBtn.onclick = () => {
        if (!document.fullscreenElement) {
            fullscreenTarget.requestFullscreen().catch(err => {
                console.error(`Fullscreen error: ${err.message}`);
            });
        } else {
            document.exitFullscreen();
        }
    };

    fullscreenTarget.onmousemove = () => {
        fullscreenTarget.classList.remove('hide-cursor');
        clearTimeout(hideTimer);
        if (document.fullscreenElement) {
            hideTimer = setTimeout(() => {
                fullscreenTarget.classList.add('hide-cursor');
            }, 3000);
        }
    };

    // 모바일 터치 이벤트 대응
    fullscreenTarget.ontouchstart = () => {
        fullscreenTarget.classList.remove('hide-cursor');
        clearTimeout(hideTimer);
        hideTimer = setTimeout(() => {
            fullscreenTarget.classList.add('hide-cursor');
        }, 3000);
    };

    playPauseBtn.onclick = togglePlay;

    seekBar.oninput = (e) => {
        currentTime = parseFloat(e.target.value);
        updateDisplay();
    };

    applyBtn.onclick = () => {
        cues = parseSubtitles(vttInput.value);
        if (cues.length > 0) {
            maxTime = Math.max(...cues.map(c => c.end)) + 1;
            seekBar.max = maxTime;
            statusDot.className = "status-dot bg-green-500";
            statusText.innerHTML = `<span class="status-dot bg-green-500"></span> ${cues.length}개 로드됨`;
            applyBtn.innerText = "적용됨";
            setTimeout(() => { applyBtn.innerText = "적용하기"; }, 1000);
        }
        updateDisplay();
    };

    document.addEventListener('keydown', (e) => {
        if (e.code === 'Space' && document.activeElement !== vttInput) {
            e.preventDefault();
            togglePlay();
        }
        if (e.code === 'KeyF') {
            fullscreenBtn.click();
        }
    });

    applyBtn.click();
</script>

</body>
</html>
